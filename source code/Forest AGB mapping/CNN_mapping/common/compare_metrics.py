# -*- coding: utf-8 -*-
"""compare_metrics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XtumEffwlb0PTorKCI6m1vn994tiEM9i
"""

import numpy as np
from numpy.linalg import norm
from skimage.measure import compare_psnr, compare_ssim, compare_mse


def mpsnr(x_true, x_pred):
    """
    :param x_true: 高光谱图像：格式：(H, W, C)
    :param x_pred: 高光谱图像：格式：(H, W, C)
    :return: 计算原始高光谱数据与重构高光谱数据的均方误差
    References
    ----------
    .. [1] https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio
    """
    n_bands = x_true.shape[2]
    p = [compare_psnr(x_true[:, :, k], x_pred[:, :, k], np.max(x_true[:, :, k])) for k in range(n_bands)]
    return np.mean(p)

def mssim(x_true,x_pred):
    """
        :param x_true: 高光谱图像：格式：(H, W, C)
        :param x_pred: 高光谱图像：格式：(H, W, C)
        :return: 计算原始高光谱数据与重构高光谱数据的结构相似度
    """
    SSIM = compare_ssim(X=x_true, Y=x_pred, multichannel=True)
    return SSIM

def computeRMSE(groundTruth, recovered):
    """
    Compute RMSE between two images
    :param groundTruth: ground truth reference image. (Height x Width x Spectral_Dimension)
    :param recovered: image under evaluation. (Height x Width x Spectral_Dimension)
    :return: RMSE between `recovered` and `groundTruth`.
    """

    assert groundTruth.shape == recovered.shape, "Size not match for groundtruth and recovered spectral images"

    difference = (groundTruth - recovered) ** 2
    rmse = np.sqrt(np.mean(difference))

    return rmse



def SAM_j(x,y):
    s = np.sum(np.dot(x,y))
    t = np.sqrt(np.sum(x**2))*np.sqrt(np.sum(y**2))
    th = np.arccos(s/t)
    
    return th  

def SAM(groundTruth,recovered):

    assert groundTruth.ndim == 3 and groundTruth.shape == recovered.shape
    

    sam_rad = np.zeros(groundTruth.shape)

    x_true = groundTruth
    x_pred = recovered
    for x in range(x_true.shape[0]):
      for y in range(x_true.shape[1]):
        temp_pred = x_pred[x,y].ravel()
        tem_true = x_true[x,y].ravel()
        sam_rad[x,y]=SAM_j(tem_true,temp_pred)
   
    sam_deg = sam_rad.mean() * 180 / np.pi
    return sam_deg